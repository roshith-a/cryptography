- 1: A fundamental principal in modern cryptographic engineering is to define clear boundaries between what is trusted (authentic) and what is not. All inputs that cause the application internal to the boundary to take a meaningful action MUST be authenticated. This perspective is well captured by the notion of an Advanced Persistent Threat and evaluating their capabilities now and in the future.

	- An advanced persistent threat was coined by the Department of Defense as an adversary with prolonged and undetected access to your networks and computer systems through advanced stealthy applications.
		- **Advanced** The adversary has the ability to evade detection and the capability to gain and maintain access to well protected networks and sensitive information contained within them. The hacker is generally adaptive and well resourced.
		- **Persistent** The persistent nature of the threat makes it difficult to prevent access to your computer network and, once the adversary has successfully gained access to your network, very difficult to remove.
		- **Threat** The adversary has not only the intent but also the capability to gain access to sensitive information stored electronically.
- 2: A second hallmark of good cryptographic design is simplicity. Complexity is the next most significant adversary in building a secure system. If an application has 20 different options each with a single on or off setting, that is over a million different configurations. A complete security analysis must incorporate a review of each scenario, an impossible task. Use simple, consistent, and well-vetted primitives aligned to the boundary interface, and executed at the earliest possible point in the application, before your program branches. This has a logarithmic reduction in the complexity of your analysis making it possible to analyze the system, and significantly lowers the probability of faulty assumptions or authentication flaws in your design. Inspectability provides security assurances.

- 3: An application will typically require a number of security services, like authentication, authorization, access control, audit, etc. Some of these services can be provided directly from the cryptographic functions, and others are built on the services that these cryptographic functions provide. The four fundamental security services provided by cryptography are (1) confidentiality or privacy, (2) data-integrity, (3) authentication and (4) non-repudiation.
- 4: An important element of a system design is mapping the sensitivity of the information to a security level. The primary measure here is really, how long do you need the information that is protected by this application kept secure? In general, you should think of two different numbers (1) at the time of entering the system how long must it be kept secure, and (2) how long will this application be active. If it is short-lived data, like a credit card number, it may only need 5 or 10 years of confidentiality. If it is longer, say DNA information, one or more lifetime of confidentiality. Once you have a notion of how long the information needs to be kept secure you can map it a security level. Using the security level, you can identify the appropriate algorithms that deliver that level of protection.
	- Security Level: measure security in work to exhaust all possible values of a symmetric key in an ideal cipher. An ideal cipher is a theoretical algorithm that has no weaknesses, and so you must try every possible key to discover which is the correct key. For instance, if you have a 128-bit key ideal cipher, then it takes 2128 work to exhaust the key space, and we say it has a 128-bit security level. It is important to realize that security level and key length are not always equal.
		- NIST SP800-57 Part 1 ([https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-57pt1r4.pdf](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-57pt1r4.pdf)), and
		- Lenstra’s Key Lengths ([https://infoscience.epfl.ch/record/164539/files/NPDF-32.pdf](https://infoscience.epfl.ch/record/164539/files/NPDF-32.pdf))
	- NOTE: It should be noted that the threat of quantum-computing is distorting these mappings in the following way: there is a reduction of frac12; of security strength for hash and symmetric keys, and a complete loss of security for finite field, integer factorization and elliptic curve discrete log.
- 5: Keys must be rotated, if at all possible. It is both a security risk and anti-pattern for a system to use cryptographic keys without also accounting for key rotation
	- Periodic key-rotation limits the time-window during which an adversary can exploit a key they happen to learn. 
	- Periodic key-rotation also prevents key 'wear out', which occurs when a key is used to encrypt more plaintext than it can securely encrypt. For example, BR recommends that AES keys encrypt no more than 2^48 blocks in any mode, and that this limit be reduced to 2^32 in modes that use IVs (e.g., counter mode or GCM).
	- Periodic key-rotation is required by a number of compliance regimes (e.g., FedRAMP, PCI) that may apply to X systems.
	- During security incidents, responders may need to rotate keys as quickly as possible to mitigate risks and/or damages.
	- recommend that you build a single key-rotation mechanism that is (1) automated, and (2) suitable for all rotation scenarios, both routine and incident-related. In some systems, it may appear that these two types of rotation scenarios have incompatible requirements. That is, routine key rotations may be subject to forms of change-management safeties (e.g., ‘zoned’ releases, health checks, human reviewers) that impose too much latency for incident tempos. One option, in that scenario, is to produce two key-rotation mechanisms: a slow mechanism that applies safety-checks for routine rotations, and a parallel quick mechanism for incident rotations that prioritizes speed. However, the incident mechanism can grow ‘stale’ and become out of sync with the system containing the keys, the relevant access control mechanisms, logging mechanisms, and so on. Instead, it is better to design a single system that applies the safety-checks by default but also has an ‘incident mode’ that (when appropriately authorized) allows the checks to be bypassed. In this way, the ‘incident’ mechanism is kept up-to-date automatically with the ‘routine' mechanism.
		- When designing this key-rotation mechanism, bear in mind that it must:
		- Be secure enough to ensure the secrecy of new keys being rotated into service,
		- Be practiced regularly (for those mechanisms which are used for incident response only), and
		- Support ‘key-overlap’: a situation where both the previous and new keys are in use simultaneously. The reason for this is that an old key must not be ‘turned off’ until you are certain that nothing depends on it any more (i.e., everything that needs the new key has the new key).
		- The 'right' rotation frequency depends upon many factors such as the value of the key (i.e., the value of the data it protects), the latency of the rotation mechanism(s), compliance requirements (if applicable), and security mechanisms that protect the key in use. Rotation periods certainly should be no more than the key's lifetime